상속
	장점
		- 기존 클래스의 필드와 메소드를 재사용
		- 일부 변경 가능
		- 검증된 소프트웨어를 재사용
		- 신뢰성 바탕, 쉽게 개발-유지 보수 쉬움
		- 중복 줄일수 있음.
		
부모클래스
	- 추상적
자식클래스
	- 구체적
	
class [자식클래스] extends [부모클래스] {}

상속받은 필드,메소드 사용
	- 멤버연산자(.) 사용
	
상속을 받을때 private x , protected/package/public o

메소드 오버라이딩
	- 자식 클래스가 필요에 따라 상속된 메소드를 다시 정의 하는 것
	- 메소드의 이름,반환형, 매개변수의 개수,데이터 타입이 정확하게 일치 해야함
	
super를 사용하여 부모 클래스 접근

상속과 생성자
	- 부모클래스 생성자 -> 자식클래스 생성자 순으로 호출
	
추상 클래스
	- 몸체가 구현되지 않은 메소드를 가지고 있는 클래스
	- 추상적인 개념을 표현
	- public abstract class Animal{
		public abstract void move(); // 추상 메소드
	  }
	
다향성
	- 객체들의 타입이 다르면 똑같은 메세지가 전달되더라도 서로 다른 동작을 하는 것
	
클래스 A의 참조 변수로 클래스 B의 객체를 참조할 수 없음

상향 형변환
	- 부모클래스의 참조 변수는 자식 클래스의 객체를 참조할 수 있음
	- 서브 클래스 객체는 수퍼 클래스 객체를 포함 하기 때문

동적 메소드 호출
	- 다형성은 동일한 메세지를 받더라도 객체의 타입에 따라서 서로 다른 동작을 함
	
동적 바인딩
	- 바인딩 : 메소드 호출을 실제 메소드의 몸체와 연결
	- 동적 바인딩 : JVM이 실행 단계에서 객체의 타입을 보고 적절한 메소드를 호출
	- 새로운 클래스가 추가되더라도 다른 코드를 변경할 필요 없음 / 시스템에 최소한의 영향을 미침

메소드의 매개변수
	- 부모클래스 참조 변수를 이용 : 다형성을 이용하는 전형적인 방법
	
Object클래스
	- java.lang 패키지에 들어있으며 자바 클래스 계층 구조에서 맨 위에 위치하는 클래스
	- getClass()
		- 클래스에 대한 정보 반환
		
equals() 메소드
	- == 연산자를 사용하여 객체의 주소가 동일한지 검사